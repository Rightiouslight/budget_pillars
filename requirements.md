# Budget Pillars - Flutter Migration Specification

## 1. Introduction & Goals

This document outlines the technical specification for migrating the "Budget Pillars" web application from a Next.js/React stack to a native cross-platform application using **Flutter**. This document is intended to be a complete blueprint for development.

### 1.1. Primary Goals

- **Native Performance:** Deliver a high-performance, smooth, native application experience for both iOS and Android users from a single codebase.
- **Maintain Feature Parity:** The Flutter application must implement all core features of the existing web application.
- **Backend Reuse:** The new application will connect to the **existing Firebase project** and utilize the same Firestore database structure and Firebase Authentication setup. No data migration is required.
- **Modern Architecture:** Employ modern, best-practice Flutter architecture using **Riverpod** for state management to ensure the application is scalable, testable, and maintainable.
- **Offline First:** Fully replicate the PWA's offline capabilities by leveraging Firestore's built-in persistence. Data must sync seamlessly when a connection is restored.

---

## 2. Technical Stack & Architecture

### 2.1. Core Stack

- **Framework:** Flutter (latest stable version)
- **Language:** Dart (latest stable version)
- **State Management:** **Riverpod** (latest stable version) with code generation (`riverpod_generator`).
- **Data Serialization:** `freezed` for immutable models and `json_serializable` for Firestore conversion.
- **Backend:** Firebase (Authentication, Firestore).
- **Routing:** `go_router` for declarative, URL-based navigation.
- **UI:** Material Design 3, customized to match the existing app's aesthetic.

### 2.2. Directory Structure (Proposed)

```
lib/
├── main.dart
|
├── /app                  # Core app setup, theme, router
│   ├── app.dart
│   ├── app_theme.dart
│   └── app_router.dart
|
├── /data                 # Data layer: repositories and models
│   ├── /firebase         # Firebase service configurations & initializers
│   │   ├── auth_repository.dart
│   │   ├── firebase_options.dart  (Generated by FlutterFire CLI)
│   │   └── firestore_repository.dart
│   └── /models           # All data models with fromJson/toJson
│       ├── account.dart
│       ├── budget.dart
│       ├── card.dart
│       ├── category.dart
│       ├── pocket.dart
│       ├── transaction.dart
│       └── ... (all other models)
|
├── /features             # Feature-based folders
│   ├── /auth             # Login, Sign Up, Password Reset
│   │   ├── auth_screen.dart
│   │   └── auth_controller.provider.dart
│   ├── /dashboard        # Main Kanban view
│   │   ├── dashboard_screen.dart
│   │   ├── dashboard_controller.provider.dart
│   │   └── /widgets
│   │       ├── account_board_widget.dart
│   │       ├── category_card_widget.dart
│   │       └── pocket_card_widget.dart
│   ├── /reports          # Reports screen
│   │   └── ...
│   └── /settings         # Settings screen
│       └── ...
|
├── /providers            # Global Riverpod providers
│   ├── active_budget_provider.dart
│   └── settings_provider.dart
|
└── /utils                # Utility functions, formatters, etc.
    └── currency_formatter.dart
```

### 2.3. State Management with Riverpod

Riverpod will be used exclusively for state management. All providers should be generated using `riverpod_generator`.

- **`@riverpod` (AsyncNotifierProvider):** For managing asynchronous state that comes from Firestore streams, such as the `MonthlyBudget`. The provider must handle fetching, error states, and loading states automatically.
- **`@riverpod` (NotifierProvider):** For managing synchronous UI state (e.g., the source card of a transfer, reordering mode).
- **`@riverpod` (Provider):** For providing immutable services and repositories (e.g., `FirestoreRepository`).
- **`family` modifier:** To create providers that take parameters, such as fetching a budget for a specific `(userId, monthKey)` combination.

### 2.4. Firebase Configuration

Firebase will be configured using the **FlutterFire CLI**. The `firebase_options.dart` file generated by this tool will be used to initialize the Firebase app. This approach ensures that the app can connect to the correct Firebase project for both iOS and Android platforms seamlessly.

---

## 3. Data Layer & Firebase Integration

The Flutter app will directly interface with the existing Firestore database.

### 3.1. Firestore Data Models (with `freezed` and `json_serializable`)

All models must be created with `fromJson` and `toJson` methods for seamless serialization. Use the `@Default()` annotation for optional fields.

**`monthly_budget.dart`**

```dart
@freezed
class MonthlyBudget with _$MonthlyBudget {
  const factory MonthlyBudget({
    required List<Account> accounts,
    required List<Transaction> transactions,
    @Default([]) List<RecurringIncome> recurringIncomes,
    @Default({}) Map<String, bool> autoTransactionsProcessed,
    @Default({}) Map<String, bool> processedRecurringIncomes,
  }) = _MonthlyBudget;

  factory MonthlyBudget.fromJson(Map<String, dynamic> json) => _$MonthlyBudgetFromJson(json);
}
```

**`account.dart`**

```dart
@freezed
class Account with _$Account {
  const factory Account({
    required String id,
    required String name,
    required String icon,
    required String defaultPocketId,
    required List<Card> cards,
  }) = _Account;

  factory Account.fromJson(Map<String, dynamic> json) => _$AccountFromJson(json);
}
```

**`card.dart`** (Sealed class using `freezed`)

```dart
@Freezed(unionKey: 'type')
sealed class Card with _$Card {
  const Card._();

  @FreezedUnionValue('pocket')
  const factory Card.pocket(
    String id,
    String name,
    String icon,
    double balance,
    String? color,
  ) = Pocket;

  @FreezedUnionValue('category')
  const factory Card.category(
    String id,
    String name,
    String icon,
    double budgetValue,
    double currentValue,
    String? color,
    @Default(false) bool isRecurring,
    int? dueDate,
    String? destinationPocketId,
    String? destinationAccountId,
  ) = Category;

  factory Card.fromJson(Map<String, dynamic> json) => _$CardFromJson(json);
}
```

_(Note: This represents a simplified version. For full `freezed` implementation, Pocket and Category might be in their own files and referenced here.)_

**`transaction.dart`**

```dart
@freezed
class Transaction with _$Transaction {
  const factory Transaction({
    required String id,
    required double amount,
    required String description,
    required DateTime date,
    required String accountId,
    required String accountName,
    required String categoryId,
    required String categoryName,
    String? targetAccountId,
    String? targetPocketId,
    String? targetPocketName,
    String? sourcePocketId,
  }) = _Transaction;

  factory Transaction.fromJson(Map<String, dynamic> json) => _$TransactionFromJson(json);
}
```

**(Other models like `UserSettings`, `ShareInvitation`, etc., must also be created following this pattern.)**

### 3.2. Firebase Repository Pattern

A `FirestoreRepository` class will abstract all Firestore operations. This service will be provided by a Riverpod `Provider`. It must handle data serialization/deserialization.

- **`Stream<MonthlyBudget?> budgetStream(String userId, String monthKey)`**: Returns a real-time stream of the budget document.
- **`Future<void> saveBudget(String userId, String monthKey, MonthlyBudget budget)`**: Saves the entire budget document.
- Other methods for user settings, sharing, etc.

### 3.3. Offline Persistence

Enable Firestore's built-in offline persistence during Firebase initialization. This is a one-line configuration change and is critical for meeting the "Offline First" requirement.

---

## 4. UI/UX and Feature Implementation

### 4.1. Main Dashboard (Kanban View)

- **Layout:** A `PageView` or a horizontally scrolling `ListView` will be used for the Account boards.
- **Account Board Widget:** A `ConsumerWidget` that displays the account summary (Total in Pockets, Available to Budget, etc.) and a vertically scrolling list of its cards.
- **Card Widgets (Pocket & Category):** Custom-built widgets that accurately reflect the design of the web app, including progress bars for categories.
- **Drag & Drop:** Use a high-quality package like `reorderable_list` to implement reordering for both Account boards (horizontally) and Cards within an account (vertically).

### 4.2. Core Logic Implementation

The Riverpod controllers (`AsyncNotifier` classes) must implement the following business logic:

- **Add Expense:**

  1.  Create a `Transaction` object.
  2.  Increase the `Category`'s `currentValue`.
  3.  Decrease the `balance` of the account's default `Pocket`.
  4.  Prepend the new transaction to the `transactions` list.
  5.  Save the updated `MonthlyBudget` object to Firestore.

- **Fund Transfer:**

  1.  UI enters a "transfer mode" when initiated.
  2.  If source is a `Pocket`, decrease its `balance`.
  3.  If source is a `Category` (a "refund"), decrease its `currentValue`.
  4.  Increase the destination `Pocket`'s `balance`.
  5.  Create a `Transaction` log for the event.
  6.  Save the updated `MonthlyBudget`.

- **Recurring Expenses & Sinking Funds:**

  - **Quick Pay:** A checkbox on a recurring category card logs a transaction for the full _remaining_ budgeted amount.
  - **Automatic Payments:**
    - On app start, a controller must check all recurring categories.
    - For each category, determine its `dueDate` for the current budget period.
    - If `today >= dueDateForPeriod` and the bill hasn't been auto-paid (check `autoTransactionsProcessed` map), trigger the "Quick Pay" logic.
    - Update the `autoTransactionsProcessed` map for that category ID and save the budget.
  - **Sinking Funds (Linked Pockets):** If `destinationPocketId` is present on a recurring category, the "Pay" action must trigger a **transfer** from the default pocket to the destination pocket, instead of a simple expense.

- **Data Import/Export:**
  - **Account Templates (JSON):** Use `file_picker` to select JSON files. Parse them using `dart:convert`. Add the parsed pockets and categories to the selected account.
  - **CSV/Text Import:** Replicate the multi-step import process (file selection, column mapping, regex for SMS, categorization review). Use the `csv` package for parsing.

### 4.3. Sharing & Collaboration

- The UI for sending, receiving, and managing invitations will be rebuilt.
- The underlying logic will call the appropriate `FirestoreRepository` methods.
- A global `ActiveBudgetProvider` will manage which budget (the user's own or a shared one) is currently being viewed. The UI must update and permissions (read-only vs. write) must be enforced based on the active budget.

---

## 5. Migration Checklist & Phasing

### Phase 1: Core Setup & Authentication

- [ ] Set up new Flutter project with Riverpod and `go_router`.
- [ ] Run `flutterfire configure` to generate the `firebase_options.dart` file and configure the project for both iOS and Android.
- [ ] Implement all data models with `freezed` and `json_serializable`.
- [ ] Implement `FirestoreRepository` with initial `budgetStream` and `saveBudget` methods.
- [ ] Implement Firebase Authentication (Email & Google) using an `AuthRepository`.
- [ ] Create login/signup screens and auth state handling.

### Phase 2: Read-Only Dashboard

- [ ] Create a global `ActiveBudgetProvider` that defaults to the user's own budget.
- [ ] Implement the main dashboard screen that consumes the `budgetStream` from the `ActiveBudgetProvider`.
- [ ] Build read-only versions of the Account, Pocket, and Category card widgets.
- [ ] Implement month navigation (previous/next).

### Phase 3: Core Write Operations

- [ ] Implement the `AsyncNotifier` controller for the dashboard to handle all mutations.
- [ ] Build dialogs and forms for adding/editing/deleting Accounts, Pockets, and Categories. These actions must call methods on the dashboard controller.
- [ ] Implement the full transaction and transfer flows.

### Phase 4: Advanced Features & Polish

- [ ] Implement drag-and-drop reordering for accounts and cards.
- [ ] Implement the "Quick Pay," automatic payment, and sinking fund logic in the dashboard controller.
- [ ] Build the Reports screen with charts (using `fl_chart`).
- [ ] Build the Settings screen.
- [ ] Build the data import/export features (Account Templates, CSV, and Text/SMS).

### Phase 5: Collaboration

- [ ] Implement the full budget sharing and invitation UI and logic.
- [ ] Implement the UI for switching between active budgets via the `ActiveBudgetProvider`.
- [ ] Thoroughly test UI state for read-only vs. write permissions.
- [ ] Test all Firestore security rules from the mobile app context.
